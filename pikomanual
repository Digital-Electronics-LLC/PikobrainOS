PIKOBRAIN MANUAL v1.2.11
Hanzlu (2019-2020)
---------------------

INTRODUCTION
------------

Pikobrain is a very small operating system of only 4kB, which still provides the user with all the basic commands to edit files, code, and so on. The operating system
is completely written in 16-bit assembly language (NASM). Pikobrain uses the hexadecimal number system. The keyboard is automatically US character set.
Lines starting with ** are technical details.

Pikobrain was originally intended to be an operating system in which I could use an low-level esoteric programming language I had made (ACL). However, those ideas where
forgotten the more I coded Pikobrain. Pikobrain was initially an operating system written with the intention to have a source code which was as small as possible. This
meant the operating system couldn't be very user-friendly or advanced, and still today Pikobrain is supposed to be quite small, but also user-friendly to an accepted
level. The name Pikobrain comes from the 'big brain meme'. Piko means 10^-12 which is small, just like Pikobrain itself. In other words, Pikobrain is the opposite of big brain.
Development begun in late 2019, and has continued since then in unregular patterns of temporary activity.


INSTALLATION
------------

Pikobrain should have access to 1MB of RAM. Hard disk space should be between at least a few kB up to about 8GB (it cannot access more). Keyboard and screen are also 
essential, as well as a USB port for booting on real hardware. The CPU should be i386 or newer (fs and gs registers are used), and allow for 20-bit segmentation.

In VirtualBox the piko.flp file can be used to boot the OS from a virtual floppy disk.
On real hardware USB drives has been tested and worked. On linux you can use the ' sudo dd if=piko.bin of=/dev/sdb ' command to write the piko.bin file to a USB drive.
However, the sdb part might be different for other people (check the ' dmesg ' command). I always format the USB stick before using the dd command, I am not sure if it
is actually necessary.

Boot from the USB. If the boot is sucessfull you shall see a two digit number followed by an S ("Success"). This means the OS has been installed successfully on your hard drive. 
Now remove the USB and boot from the hard drive. If the boot is successfull you should see a blinking green cursor. You are now in Pikobrain. Try the t command for example.

COMMANDS
--------

Commands in Pikobrain are done by pressing keys. Each command is only one character long, and do not require the user to press enter. You always use lowercase letters
when entering commands, since lowercase and uppercase letters are interpreted as different. Most commands also take arguments. Arguments are inserted as two digit (or
more digits) hexadecimal numbers (most of the time). Hexadecimal numbers are ALWAYS written in upper case such as B8. When pressing a command key it will not be displayed on the screen, however the arguments are displayed (most of the time). If you want to quit writing a command (perhaps you wrote the wrong number)
you can press the backspace button. This will bring you back to the "input" where you enter commands. **This can fill up the stack with unused ip values.
Here is a list of the commands you can use within Pikobrain and how they work:

t, time:
Displays the current time in hh:mm:ss format. Daylight saving time not supported.

d, date:
Displays the current date in yyyy/mm/dd format.

enter, enter:
Newline and carriage return as expected.

n, new:
Clears the screen and moves the cursor to the top left.

The following commands take multi digit numbers as arguments. They are always of a certain lenght which means that if you want to enter the number 1, you will have to
write 01 for example, by adding zero(s) in the begining.

k, kalculator:
Enter a four digit hexadecimal number. A newline will automatically be written. Enter a second four digit hexadecimal number. Then press a number key for operation
according to this list:
1=add
2=subtract
3=multiply
4=divide
5=modulus (remainder in division)
6=and
7=or
8=xor
9=not
0=floating point division, will return a four digit hexadecimal number, which is the floating point part of the division

6-9 are bitwise operations.
You should then be displayed with a four digit hexadecimal number which is the answer.

h, hex:
Enter a four digit hexadecimal number. You will be displayed with the number converted into decimal.

x, xdec:
Enter a 5 digit decimal number (max 65535). You will be displayed with the number converted into hexadecimal.

. (dot), float:
Enter a 4 digit hexadecimal number. This is the floating point part of a number. For example 1/3 = 0.5555 in hexadecimal floating point. If you enter the value
5555 you'll convert the value into a decimal floating point number, 0.333333. This will be displayed as a dot followed by six digits. This command is not 100% accurate
in all digits, often the first 4 digits are accurate.

o, os:
Displays information about the computer. All numbers are in hexadecimal.
First number is the number of the boot device. If you have booted from hard drive you must make sure the number is 80. Else file operations will not work. Please
contact Hanzlu if the number is different.
Second number is the highest folder number you can enter. This number should always be known by the user. It shall also be known that the number is three 2-digit hexadecimal numbers and each of the numbers can not be higher than it is. For example my test machine displayes the number 03FEFE, which means I cannot enter folder
03FEFF, because that exceeds the limit of the third 2-digit hexadecimal number. More info about folders in the FOLDERS and FILES categories.
Third number is the highest file you can access within a single folder.

FOLDERS
-------

You should make sure to test the o command before dealing with folders. The o command tells you the highest folder number(s) you may enter. If you exceed the limit strange stuff might happen, I don't know I haven't tried.
The first 2 digit hexadecimal number of the current folder can be a maximum of 03, even if you have a massive hard drive, as Pikobrain can only access a maximum
of 8GB of hard disk space. Make sure to know the second and third 2-digit number limitations with the o command so you do not exceed their limits.
You are always in folder 000000 when you enter the operating system, the 'home' folder. Files 01-09 are reserved for the operating system, do not edit them if you do 
not know what you are doing, as they contain the OS machine code.
When inserting a folder number as an argument you can use some shortcuts. By pressing two times on the enter button you will select the current folder. This will move 
the cursor to the begining of the line and display a star '*'. By pressing two times on the h letter key you select the 'home' folder (000000).
By pressing semi-colon twice you'll be able to insert a two digit number to alter only the last two digits of the file number.
When you use these shortcuts you must only do two (or four) key presses rather than 6. Whenever you insert values, they are saved, so if you enter 02 and then press
backspace, the 02 will still be saved.

f, folder:
Changes the folder to the 6 digit hexdecimal number you insert. Make sure you do not exceed limits. 

i, info:
Displays information about the current folder you are within. Displays the folder number followed by the files within the folder. Only files that do not have an ASCII 
00 (hex) character as its first character will be displayed. 
Files are displayed with their number, followed by a dot and the first 10 characters of the file. The first 10 characters can therefore be used as a file name.
Special characters outside of the range ASCII 20-7F (hex) are displayed as stars *.

z, zero:
Fills all files within a folder with ASCII 0 (null) characters. In other words, deletes the files and the whole folder. It fills all files that do not have an ASCII 0 (null) character as its
first character, as those files are seen as empty by the OS. 
In order to run the command you must press the y key after an ! character (warning) has been shown, as you probably do not want to press z in mistake. You will be displayed with the character you press.

s, search:
Enter a character, word or string. Pikobrain will display which files within the current folder that has that character, word or string within them. Press enter to start the search.

FILES
-----

In order to access a file you enter a file number after a file manipulation command. A file number is normally in the range 00-3F (hex) (check the o command).
Files in Pikobrain are automatically 512 bytes long. You can't change this, besides with your own imagination.

w, write:
Enter a file number. You can now write a file. You can use the enter button and the backspace button. The enter character (newline) is 2 characters (0xd and 0xa hex ASCII), and backspace erases both at once. Spaces before newline characters are automatically removed, as else backspace will work unexpectedly.
You can use the left and right arrow keys to move the cursor around the document.
In order to copy text which you can paste later, you press the down arrow. Pikobrain remembers the character at which the cursor is. When you press the down arrow a
second time Pikobrain will save all the text between the two key presses. **Now Pikobrain has a buffer of text which you can paste.
To paste text you have copied you press the up arrow. This will paste the characters between your first and second down-arrow-presses. It's possible to copy-paste
between files.
You can write special characters (ASCII 00-FF) in Pikobrain. Press the \ key and type a two digit hexadecimal number for a character's ASCII representation. This allows you access to characters outside of the ASCII 20-7F scope. Characters in the range 00-1F might be 'invisible' and not be printed expectedly, but will be stored.
Notice, that you should not cancel the writing of the two digit number by pressing backspace, as this will actually make you return to the 'input'.
If you hold shift and the ` button (left of 1) you'll be displayed with a ~ character and a four digit hexadecimal number. This number shows you the number of characters
the file currently holds out of the maximum 512 bytes (0200 hex). Press any key and you can continue writing.
In order to save a file you press the button to the left of the 1 key. This should display ``, which means the file has been saved. In order to cancel writing you
press the tab key. This should display a small circle.
If you write 512 characters you reach the file size limit in Pikobrain. The file will be automatically saved and a ` character will be displayed. If you save a file
before reaching the limit, the rest of the space will be filled with null characters (ASCII 0).

e, edit:
Works the same way as the w command but will display the file content and allow you to continue writing from the end of the file.

r, read:
Enter a file number. The file will be displayed in ASCII format. Read file 01 in folder 000000 and you'll get a list of Pikobrain commands.
**Characters are read until a null character is found.

m, memory:
Works like the r command but displays the file in hexadecimal form, like a .bin file. However, it shows all content of the file.

c, copy:
Enter a file number for the source file. Enter the number of files to read as a two digit hexadecimal number. A 'w' character should be displayed.
Enter the destination folder's number (6 digit hexadecimal number or a shortcut). Enter the destination file's number. A ` character shall be displayed and the file has been copied. 

CODING
------

**The OS often uses a buffer starting at 0x1200:0x0 (20 bit segmentation), including when loading machine code into RAM with the 'p' command. Thus, you should not use
that buffer in your own programs as you will alter the code your program is running from.
**Programs may not start with a jump. This is due to how jumps are assembled.

Pikobrain has a limited assembler. The assembly language is a custom version of assembly language. The code is written in consecutive files within single folders.
The code is written in upper case with one exception.
Mneumonics are either one or two characters wide. Mneumonics which can take two registers as arguments and jump mneumonics are typically 2 chracters wide. 
If a mneumonic can either use a register or immediate value as source, this must be indicated in the mneumonic. For example if you want to move bx into ax, you must 
specify that the source is a register by using the MR (move register) mneumonic. On the other hand, if the source is a value (and all values are hexadecimal) such as 10 
(hex) you must specify this by using the mneumonic MN (move number). Like this: MN AL 10
If you for example want to move the number 1 to ax you must add pending zeros: MN AX 0001 (ax is 16 bit)
In normal assembly language a comma is used between destination and source. This is not required in the Pikobrain version. It is also not required to use newlines
between various mneumonics. In fact, you do not even need spaces at all in the Pikobrain version.
All the basic registers (AX, AH, AL, BX, BH..) are usable. You can also use SI and DI, however they are called SX and TX and are 16 bit.
Segmentation is possible only through ES:BX. Read the 'Other Commands' part for this.
Here is a list of 2 character mneumonics in Pikobrain (2 arguments, destination and source) (each require either an R or an N at the end such as MR or MN, not just M):
M, move
A, add
S, subtract
B, both (and)
O, or
X, xor
C, compare

Here is a list of 2 character mneumonics taking two arguments; a 8-bit register and a number (byte) and the mneumonic ends with either R (right) or L (left):
Z, (shift), ZR = shr, ZL = shl
Q, (rotate), QR = ror, QL = rol
Notice that these mneumonics cannot use 16-bit registers.

Here is a list of 2 character mneumonics taking only a number (byte) as argument and where the mneumonic ends with either I (in) or O (out):
G, GI = in, GO = out
notice that the al register is automatically used so you do not specify a registor, just the number.

Here is a list of 1 character mneumonics in Pikobrain (one argument). Mneumonics marked with a * can only have 16 bit registers as arguments (and work in a special 
way), those marked with a / can only take a value (byte) as argument, those with a \ can only take registers:
T, times\ (mul)
D, divide\
H, higher\ (inc)
L, lower\ (dec)
N, not\
I, int/
U, push* (if you want to push ax you write UA, so no X and everything in one mneumonic. UA, UB, UC UD, US and UT are in other words the ones you can use. Same for pop below)
P, pop* (PA, PB, PC, PD, PS, PT)
K, kreate/ (db) (defines a byte (K 20))

Control flow:
Labels are marked as words starting and ending with dots such as .LOOP. When jumping to a label you use 'JM <label name>.' Label names end with a dot but do not start
with them, so in order to jump to the LOOP label you write 'JM LOOP.'
In order to call a function you use F (function) (call) followed by a label name similar to JM.
In order to return from a function call you must write an R (ret).
The following conditional jumps exist:
JE, jump equal
JN, jump not equal (jne)
JG, jump greater
JA, jump above or equal (jge)
JL, jump less
JB, jump below or equal (jle)
JO, jump overflow
JS, jump signed
JP, jump parity
The conditional jumps works like JM regarding the labels 

Segmentation:
Segmentation is possible with es:bx, fs:si and gs:di:
MEE, mov es, ax
MEA, mov [es:bx], al
MAE, mov al, [es:bx]
MFF, mov fs, ax
MFA, mov [fs:si], al
MAF, mov al, [fs:si]
MGG, mov gs, ax
MGA, mov [gs:di], al
MAG, mov al, [gs:di]
User made programs should use segmentation starting from 5000:0000, else you might get into space that the OS uses. **Whereas it could not be a problem to do segmentation
below 5000:0000, you should at least not do it near 1200:0000 as that is where pikobrain reads the hard disk. The text editor's copy function uses location 2100:0000 and
the bytes following that location, so do not do anything there if you want copying to work.

Macros:
To simplify some of the programming, you can access some of the functions Pikobrain call by using the following mneumonics. The list describes the functions and lists
the registers that are affected by using the macro:
WA, converts al from ASCII to HEX. If al is 42 (ascii B) for example it becomes 0B as that is hexadecimal. [al]
WE, prints a newline. [ax]
WF, same as the f command from the input. Let's the user insert a folder number and stores at 0x1000:0x11fd-0x11ff. [ax, cl, fs, si]
WH, convert al from HEX to ASCII. If al is 0C for example it becomes 43 (ascii C). [al]
WN, let's the user input a two digit hex number which is stored in cl. The user cannot press backspace as this will make the program end and jump back to the input. [ax, cl]
WS, is used to set dh, ch, and cl before a file operation (int 13h). It takes the values inserted when using WF, and are all set to 0 at bootup. [ax, cx, dh, fs, si]
WW, works like the n command in the input, clears the screen. [ax, bh, cx, dx]
WX, outputs the value in ch as ASCII. If ch is 34 hex for example, it will be printed as "34". [ax, ch]

Other commands:
E, End (this will ask the user for a key press and return the control of the computer back to the OS) (this command is necessary when ending a program)
e, end (this marks the end of the source code, the command is necessary for the ending the source code)
The E and e should probably be consecutive in the code when you which for the program to end. You can have multiple E mneumonics but only one e mneumonic.
;, comment. Allows you to type anything until the next newline character without affecting the assembler process. Notice that the comment end with a newline.
", string. Prints any text until the next " character. Basically a print function. You must be in a text video mode in order for it to work. Alters the value of AX.

In order to assemble assembly code you press 'a' for the assembly command. The enter the file number of the first file in the program. Then how many files to read 
(2 digit hexadecimal) as the source code must be in consecutive files. 
Then you should see a 'a' character for assembled on the screen. Otherwise you might see an e for 'error' (read about errors below). Now enter the destination file 
where the binary code will be placed. If your program is large, the machine code might span over several files.

Errors
If you get an error you will se a four digit number telling you at what character in the assembly code the error is, followed with an e. If you also see an 'a' 
character this means the program as been assembled up until that point where the error is found. This allows you to see where in the machine code the error is.
If you do not get a four digit number before the e character it means it is a label error. Make sure to spell labels right.
If you get the four digit number and two e characters it means you have both a general error and a label error.


p, program:
The 'p' command allows you to run binary files such as assembled code. Enter the file number of the first binary file in the program. Enter a second two digit hexadecimal number for how man consecutive files shall be read. The instruction pointer will jump to the user's program. Therefore it is necessary to include the Ee mneumonics in the code, so that control is given back to the operating system.

**CUSTOMIZATION
---------------
By altering the value at location 1000:020E you can change the colors the screen has.

TROUBLES
--------

If you come across issues please contact Hanzlu on GitHub.
I will not stand responsible for your use of the OS, it is on your own risk. That does not mean that it is not safe. I always test and improve the OS to eliminate
bugs, increase user friendliness and unwanted consequences.
If the OS has stopped working somehow, even when you restart the computer, try simply reinstalling the OS.


